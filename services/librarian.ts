import { getAllMemories, getFollowUps } from './db';
import { getIntelligenceLog } from './intelligenceLog';
import { IntelligenceFollowUp, Memory } from '../types';

export type LibrarianResultType = 'memory' | 'intelligence' | 'followup';

export interface LibrarianResult {
  id: string;
  type: LibrarianResultType;
  title: string;
  snippet: string;
  link: string;
  timestamp: number;
  score: number;
}

const tokenize = (text: string): string[] =>
  text
    .toLowerCase()
    .split(/[^a-z0-9]+/i)
    .filter(Boolean);

const scoreMatch = (queryTokens: string[], targetTokens: string[]): number => {
  if (queryTokens.length === 0 || targetTokens.length === 0) return 0;
  let score = 0;
  const targetSet = new Set(targetTokens);
  queryTokens.forEach(token => {
    if (targetSet.has(token)) score += 3;
    else {
      // partial match
      const found = targetTokens.some(target => target.startsWith(token) || target.includes(token));
      if (found) score += 1;
    }
  });
  return score;
};

const buildMemoryResult = (memory: Memory, queryTokens: string[]): LibrarianResult | null => {
  const text = `${memory.summary} ${memory.tags.join(' ')} ${memory.conversation}`;
  const tokens = tokenize(text);
  const score = scoreMatch(queryTokens, tokens) + (memory.relevance ?? 0) * 0.05;
  if (score <= 0) return null;
  const snippet = memory.summary || memory.conversation.slice(0, 160);
  return {
    id: `memory-${memory.id ?? 'unknown'}`,
    type: 'memory',
    title: memory.summary || 'Conversation Memory',
    snippet,
    link: '/memory',
    timestamp: memory.timestamp,
    score
  };
};

const buildIntelResult = (record: ReturnType<typeof getIntelligenceLog>[number], queryTokens: string[]): LibrarianResult | null => {
  const text = `${record.summary ?? ''} ${JSON.stringify(record.requestPayload ?? {})} ${JSON.stringify(record.responsePayload ?? {})}`;
  const tokens = tokenize(text);
  const score = scoreMatch(queryTokens, tokens);
  if (score <= 0) return null;
  return {
    id: record.id,
    type: 'intelligence',
    title: record.summary || `Intelligence: ${record.category ?? record.source}`,
    snippet: record.summary || 'Automated intelligence log entry.',
    link: '/chat',
    timestamp: record.timestamp,
    score
  };
};

const buildFollowUpResult = (followUp: IntelligenceFollowUp, queryTokens: string[]): LibrarianResult | null => {
  const text = `${followUp.title} ${followUp.description ?? ''} ${followUp.category} ${followUp.actionHint?.description ?? ''}`;
  const tokens = tokenize(text);
  const score = scoreMatch(queryTokens, tokens) + (followUp.priority === 'high' ? 3 : followUp.priority === 'medium' ? 1 : 0);
  if (score <= 0) return null;
  return {
    id: followUp.id,
    type: 'followup',
    title: followUp.title,
    snippet: followUp.description ?? followUp.actionHint?.description ?? 'Follow-up task generated by intelligence.',
    link: followUp.actionHint?.path ?? '/team',
    timestamp: followUp.updatedAt,
    score
  };
};

export const searchKnowledge = async (query: string): Promise<LibrarianResult[]> => {
  const trimmed = query.trim();
  if (!trimmed) return [];
  const queryTokens = tokenize(trimmed);
  if (queryTokens.length === 0) return [];

  const [memories, followUps, intelligence] = await Promise.all([
    getAllMemories(),
    getFollowUps(),
    Promise.resolve(getIntelligenceLog())
  ]);

  const results: LibrarianResult[] = [];
  memories.forEach(memory => {
    const result = buildMemoryResult(memory, queryTokens);
    if (result) results.push(result);
  });
  followUps.forEach(followUp => {
    const result = buildFollowUpResult(followUp, queryTokens);
    if (result) results.push(result);
  });
  intelligence.forEach(record => {
    const result = buildIntelResult(record, queryTokens);
    if (result) results.push(result);
  });

  return results
    .sort((a, b) => {
      if (b.score === a.score) return b.timestamp - a.timestamp;
      return b.score - a.score;
    })
    .slice(0, 40);
};
