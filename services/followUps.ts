import type { IntelligenceRecord } from './intelligenceLog';
import { IntelligenceFollowUp } from '../types';
import { addFollowUp, getFollowUpBySourceRecord, getClientProfile } from './db';

const hours = (count: number) => count * 60 * 60 * 1000;

const buildBrandFollowUp = async (record: IntelligenceRecord): Promise<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>> => {
  const changedFields = Array.isArray(record.requestPayload?.changedFields)
    ? (record.requestPayload?.changedFields as Array<{ field?: string; value?: unknown }>)
        .map(entry => (typeof entry.field === 'string' ? entry.field : null))
        .filter((field): field is string => Boolean(field))
    : [];

  const descriptionParts: string[] = [];
  if (changedFields.length > 0) {
    descriptionParts.push(`Updated fields: ${changedFields.join(', ')}`);
  }
  if (record.summary) {
    descriptionParts.push(record.summary);
  }

  return {
    title: 'Review brand intelligence update',
    description: descriptionParts.join('\n'),
    category: 'brand',
    status: 'pending',
    sourceRecordId: record.id,
    sourceSummary: record.summary,
    priority: 'medium',
    dueAt: Date.now() + hours(4),
    autoGenerated: true,
    actionHint: {
      label: 'Open Brand Intelligence',
      path: '/brand',
      description: 'Review updated brand fields and confirm positioning is aligned.'
    },
    metadata: {
      changedFields
    }
  };
};

const buildClientFollowUp = async (record: IntelligenceRecord): Promise<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>> => {
  const clientId = typeof record.requestPayload?.clientId === 'string' ? (record.requestPayload.clientId as string) : null;
  let clientName: string | null = null;

  if (clientId) {
    const profile = await getClientProfile(clientId);
    clientName = profile?.name ?? null;
  }

  const changedFields = Array.isArray(record.requestPayload?.changedFields)
    ? (record.requestPayload.changedFields as Array<{ field?: string; value?: unknown }>)
        .map(entry => (typeof entry.field === 'string' ? entry.field : null))
        .filter((field): field is string => Boolean(field))
    : [];

  const descriptionParts: string[] = [];
  if (clientName) {
    descriptionParts.push(`Client: ${clientName}`);
  }
  if (changedFields.length > 0) {
    descriptionParts.push(`Updated fields: ${changedFields.join(', ')}`);
  }
  if (record.summary) {
    descriptionParts.push(record.summary);
  }

  return {
    title: clientName ? `Follow up with ${clientName}` : 'Review client dossier update',
    description: descriptionParts.join('\n'),
    category: 'client',
    status: 'pending',
    sourceRecordId: record.id,
    sourceSummary: record.summary,
    priority: 'medium',
    dueAt: Date.now() + hours(12),
    autoGenerated: true,
    actionHint: {
      label: 'Open Client Profiles',
      path: clientId ? `/clients?focus=${clientId}` : '/clients',
      description: 'Make sure next steps and outreach tasks are captured.'
    },
    metadata: {
      clientId,
      changedFields
    }
  };
};

const buildMissionFollowUps = async (
  record: IntelligenceRecord
): Promise<Array<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>>> => {
  const completed = record.derivedMissionProgress?.filter(update => update.completed) ?? [];
  if (completed.length === 0) return [];

  const celebrationTasks = completed.map(update => {
    const missionLabel = update.title || update.missionId;
    return {
      title: `Broadcast mission win: ${missionLabel}`,
      description: `Mission ${missionLabel} wrapped with +${update.rewardXp ?? 0} XP. Announce the win and hype the team.`,
      category: 'mission' as const,
      status: 'pending' as const,
      sourceRecordId: record.id,
      sourceSummary: record.summary,
      priority: 'high' as const,
      dueAt: Date.now() + hours(2),
      autoGenerated: true,
      actionHint: {
        label: 'Share the Win',
        path: '/progress',
        description: 'Post a celebration note and ensure teammates see the XP payout.'
      },
      metadata: {
        missionId: update.missionId,
        rewardXp: update.rewardXp
      }
    };
  });

  const debriefTasks = completed.map(update => {
    const missionLabel = update.title || update.missionId;
    return {
      title: `Capture learnings: ${missionLabel}`,
      description: `Log a quick debrief for ${missionLabel}. Collect highlights, blockers, and next mission ideas.`,
      category: 'mission' as const,
      status: 'pending' as const,
      sourceRecordId: record.id,
      sourceSummary: record.summary,
      priority: 'medium' as const,
      dueAt: Date.now() + hours(6),
      autoGenerated: true,
      actionHint: {
        label: 'Log Debrief Notes',
        path: '/progress',
        description: 'Capture takeaways and note what should roll into the next mission.'
      },
      metadata: {
        missionId: update.missionId
      }
    };
  });

  return [...celebrationTasks, ...debriefTasks];
};

const buildOperationsFollowUp = async (record: IntelligenceRecord): Promise<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>> => ({
  title: 'Review operational signal',
  description: record.summary ?? 'New operational intelligence needs review.',
  category: 'operations',
  status: 'pending',
  sourceRecordId: record.id,
  sourceSummary: record.summary,
  priority: 'low',
  dueAt: Date.now() + hours(24),
  autoGenerated: true,
  actionHint: {
    label: 'Open Team Board',
    path: '/team',
    description: 'Evaluate the operational insight and adapt plans if needed.'
  }
});

const buildSocialFollowUp = async (record: IntelligenceRecord): Promise<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>> => ({
  title: 'Assess social intelligence insight',
  description: record.summary ?? 'Evaluate latest conversational analysis.',
  category: 'social',
  status: 'pending',
  sourceRecordId: record.id,
  sourceSummary: record.summary,
  priority: 'low',
  dueAt: Date.now() + hours(12),
  autoGenerated: true,
  actionHint: {
    label: 'Jump to Chat',
    path: '/chat',
    description: 'Check the conversation thread that triggered this insight.'
  }
});

export const processIntelligenceFollowUps = async (record: IntelligenceRecord): Promise<void> => {
  try {
    const followUpsToCreate: Array<Omit<IntelligenceFollowUp, 'id' | 'createdAt' | 'updatedAt'>> = [];

    switch (record.category) {
      case 'brand': {
        followUpsToCreate.push(await buildBrandFollowUp(record));
        break;
      }
      case 'client': {
        followUpsToCreate.push(await buildClientFollowUp(record));
        break;
      }
      case 'mission': {
        followUpsToCreate.push(...(await buildMissionFollowUps(record)));
        break;
      }
      case 'operations': {
        followUpsToCreate.push(await buildOperationsFollowUp(record));
        break;
      }
      case 'social':
      default: {
        if (record.summary) {
          followUpsToCreate.push(await buildSocialFollowUp(record));
        }
        break;
      }
    }

    if (followUpsToCreate.length === 0) {
      return;
    }

    const createdIds: string[] = [];
    for (const payload of followUpsToCreate) {
      const exists = await getFollowUpBySourceRecord(payload.sourceRecordId, payload.title);
      if (exists) continue;
      const created = await addFollowUp(payload);
      createdIds.push(created.id);
    }

    if (createdIds.length > 0) {
      record.triggeredFollowUpIds = [...(record.triggeredFollowUpIds ?? []), ...createdIds];
    }
  } catch (error) {
    console.error('Failed to generate follow-up from intelligence record:', error);
  }
};
